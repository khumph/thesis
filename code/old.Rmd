---
title: 'Old code for thesis'
output: html_document
---

# reward functions as defined in paper

```{r}
R2 <- function(W_next, W) {
  dW <- W_next - W
  ifelse(
    dW <= -0.5,
    5,
    ifelse(
      dW > 0.5,
      -5,
      0
    )
  )
}

R3 <- function(M_next, M) {
  ifelse(M_next == 0 & M == 0,
         0,
         ifelse(M_next == 0,
                15,
                ifelse(
                  M_next - M < -0.5,
                  5,
                  ifelse(M_next - M > 0.5,
                         -5,
                         0)
                )))
}
```

# sim-int

```{r}
# simulation functions ----------------------------------------------------

# function for how toxicity changes
updateW <- function(M, W, D, a1 = 0.1, b1 = 1.2, d1 = 0.5) {
  W_next <- a1 * M + b1 * (D - d1) + W
  ifelse(W_next > 0, W_next, 0)
}

# function for updating tumor mass
updateM <- function(M, W, D, X, a2 = 0.15, b2 = 1.2, d2 = 0.5) {
  # takes current value of tumor mass, outputs next value
  M_next <- ifelse(M > 0,
                   (a2 * W - b2 * (D * ifelse(X > 0.5, 2, 1) - d2)) + M,
                   0)
  ifelse(M_next > 0, M_next, 0)
  # (a2 * W - b2 * (D - d2)) + M
}

# reward functions
R2 <- function(W_next, W) {
  -10 * (W_next - W)
}

R3 <- function(M_next, M) {
  ifelse(M_next == 0 & M == 0,
         0,
         ifelse(M_next == 0,
                15,
                -10 * (M_next - M)))
}

reward <- function(M_next, M, W_next, W, died) {
  R2(W_next, W) +
    R3(M_next, M) +
    ifelse(died == 1, -60, 0)
}

reward_est <- function(M_next, M, W_next, W, pdied) {
  R2(W_next, W) +
    R3(M_next, M) +
    -60 * pdied
}

lambda <- function(W, M, mu0 = -7, mu1 = 1, mu2 = 1) {
  exp(mu0 + mu1 * W + mu2 * M)
}

pDeath <- function(M_next, W_next) {
  lam <- lambda(W_next, M_next)
  deltaF <- exp(-lam)
  1 - deltaF
}

# sim ---------------------------------------------------------------------

simMonth <- function(dat) {
  dat %>%
    mutate(
      M_next = ifelse(!dead, updateM(tumor_mass, toxicity, dose, X), NA),
      W_next = ifelse(!dead, updateW(tumor_mass, toxicity, dose), NA),
      d_next = runif(nrow(.), min = 0, max = 1),
      died = rbinom(nrow(.), 1, pDeath(M_next, W_next)),
      dead = ifelse(dead,
                    T,
                    ifelse(died == 1, T, F)),
      reward = reward(
        M_next = M_next,
        M = tumor_mass,
        W = toxicity,
        W_next = W_next,
        died
      )
    )
}

sim <- function(N = 1000, Ttot = 6) {
  dat <- tibble(
    ID = 1:N,
    month = rep(0, N),
    tumor_mass = runif(N, min = 0, max = 2),
    toxicity = runif(N, min = 0, max = 2),
    X = runif(N, min = 0, max = 1),
    dose = runif(N, min = 0.5, max = 1),
    dead = rep(F, N)
  )
  d <- simMonth(dat)
  out <- d
  for (i in 1:(Ttot - 1)) {
    d <- d %>% mutate(month = i,
                      tumor_mass = M_next,
                      toxicity = W_next,
                      dose = d_next) %>% simMonth()
    out <- bind_rows(out, d)
  }
  d <- d %>% mutate(month = Ttot,
                    tumor_mass = M_next,
                    toxicity = W_next,
                    dose = NA, died = NA, dead = NA,
                    reward = NA)
  bind_rows(out, d) %>%
    select(ID, month, tumor_mass,
           toxicity, X, dose, died, dead, reward)
}

# best possible -----------------------------------------------------------

maxMonth <- function(dat, len = 101) {
  dat %>% ungroup() %>% 
    mutate(dose = map(1:nrow(.), ~ seq(0, 1, length.out = len))) %>%
    unnest() %>%
    mutate(
      M_next = updateM(tumor_mass, toxicity, dose, X),
      W_next = updateW(tumor_mass, toxicity, dose),
      pdied = pDeath(M_next, W_next),
      reward = reward_est(
        M_next = M_next,
        M = tumor_mass,
        W = toxicity,
        W_next = W_next,
        pdied
      )
    ) %>% group_by(ID) %>% mutate(
      max = max(reward),
      best = ifelse(near(reward, max), dose, NA),
      best = ifelse(
        tumor_mass > 0,
        max(best, na.rm = T),
        min(best, na.rm = T)
      )
    ) %>% filter(near(dose, best))
}

# sim test refactored -----------------------------------------------------

simMonthT <- function(dat) {
  optimD <- max_df(
    data = filter(dat, group == "optim"),
    model = Q$mod_list[[dat$month[1] + 1]],
    form = Q$formula,
    mod_type = Q$mod_type
  )$best
  
  bestD <- maxMonth(filter(dat, group == "best"))$dose
  
  dat %>%
    mutate(
      M_next = updateM(tumor_mass, toxicity, dose, X),
      W_next = updateW(tumor_mass, toxicity, dose),
      d_next = ifelse(group == "optim", optimD,
                      ifelse(group == "best", bestD, dose)), 
      pdeath = pDeath(M_next, W_next),
      reward = reward_est(M_next, tumor_mass, W_next, toxicity, pdeath)
    )
}

sim_test <- function(Q, npergroup = 200, ngroups = 12, Ttot = 6) {
  M0 <- runif(npergroup, min = 0, max = 2)
  W0 <- runif(npergroup, min = 0, max = 2)
  X <- runif(npergroup, min = 0, max = 1)

  dat <- tibble(
    ID = 1:npergroup,
    month = rep(0, npergroup),
    tumor_mass = M0,
    toxicity = W0,
    X = X,
    dead = rep(F, npergroup)
  )
  
  D1 <- rep(seq(from = 0.1, to = 1, by = 0.1), each = npergroup)
  
  D0 <-
    max_df(
      data = dat,
      model = Q$mod_list[[1]],
      form = Q$formula,
      mod_type = Q$mod_type
    )$best
  
  Dbest <- maxMonth(dat)$dose
  
  groups <- c(
    seq(from = 0.1, to = 1, by = 0.1) %>% as.character(),
    "best",
    "optim")
  
  dat <- tibble(
    ID = rep(1:(npergroup * ngroups)),
    group = rep(groups, each = npergroup),
    month = rep(0, npergroup * ngroups),
    tumor_mass = rep(M0, ngroups),
    toxicity = rep(W0, ngroups),
    X = rep(X, ngroups),
    dose = c(D1, Dbest, D0),
    dead = rep(F, npergroup * ngroups)
  )
  
  d <- simMonthT(dat)
  out <- d
  for (i in 1:(Ttot - 1)) {
    d <- d %>% mutate(month = i,
                      tumor_mass = M_next,
                      toxicity = W_next,
                      dose = d_next) %>% simMonthT()
    out <- bind_rows(out, d)
  }
  d <- d %>% mutate(month = Ttot,
                    tumor_mass = M_next,
                    toxicity = W_next,
                    dose = NA,
                    reward = NA)
  out <- bind_rows(out, d)
  out %>%
    select(ID, group, month, tumor_mass, toxicity, dose, pdeath, reward) %>%
    group_by(ID) %>%
    mutate(tot_reward = sum(reward, na.rm = T))
}


# results functions -------------------------------------------------------

plots_tab <- function(dat_test_long) {
  dat_long_summ <- dat_test_long %>% group_by(group, month) %>%
    summarise(
      mean_tox = mean(toxicity, na.rm = T),
      mean_tumor = mean(tumor_mass, na.rm = T),
      mean_reward = mean(reward, na.rm = T)
    ) %>% mutate(sum_means = mean_tox + mean_tumor)
  
  plot_tox <- ggplot(data = dat_long_summ) +
    geom_line(mapping = aes(
      x = month,
      y = mean_tox,
      color = group,
      group = group
    ))
  
  plot_tumor <- ggplot(data = dat_long_summ) +
    geom_line(mapping = aes(
      x = month,
      y = mean_tumor,
      color = group,
      group = group
    ))
  
  plot_sum <- ggplot(data = dat_long_summ) +
    geom_line(mapping = aes(
      x = month,
      y = sum_means,
      color = group,
      group = group
    ))
  
  plot_reward <- ggplot(data = dat_long_summ) +
    geom_line(mapping = aes(
      x = month,
      y = mean_reward,
      color = group,
      group = group
    ))
  
  tab_deaths <-
    dat_test_long %>% group_by(group) %>%
    summarise(pdeath = sum(pdeath, na.rm = T) / n()) %>%
    arrange(pdeath)
  
  tab_reward <-
    dat_test_long %>% select(ID, group, tot_reward) %>% unique() %>%
    group_by(group) %>%
    summarise(avg_tot_reward = mean(tot_reward)) %>%
    arrange(desc(avg_tot_reward))
  
  list(
    plot_tox = plot_tox,
    plot_tumor = plot_tumor,
    plot_sum = plot_sum,
    plot_reward = plot_reward,
    table_deaths = tab_deaths,
    table_rewards = tab_reward
  )
}
```



```{r}
best_possible <- function(dat_long) {
  dat <- dat_long %>% filter(month == 0) %>% mutate(month = as.numeric(month))
  d <- maxMonth(dat)
  out <- d
  for (i in 1:6) {
    d <- d %>% mutate(month = i) %>%
      select(ID,
             month,
             tumor_mass = M_next,
             toxicity = W_next,
             dose,
             pdied,
             reward) %>% maxMonth()
    out <- bind_rows(out, d)
  }
  out
}
```

# sim-noise

```{r}
# simulation functions ----------------------------------------------------

# function for how toxicity changes
updateW <- function(M, W, D, a1 = 0.1, b1 = 1.2, d1 = 0.5) {
  W_next <- a1 * M + b1 * (D - d1) + W
  ifelse(W_next > 0, W_next, 0)
}

# function for updating tumor mass
updateM <- function(M, W, D, a2 = 0.15, b2 = 1.2, d2 = 0.5) {
  # takes current value of tumor mass, outputs next value
  M_next <- ifelse(M > 0,
                   (a2 * W - b2 * (D - d2)) + M,
                   0)
  ifelse(M_next > 0, M_next, 0)
  # (a2 * W - b2 * (D - d2)) + M
}

# reward functions
R2 <- function(W_next, W) {
  -10 * (W_next - W)
}

R3 <- function(M_next, M) {
  ifelse(M_next == 0 & M == 0,
         0,
         ifelse(M_next == 0,
                15,
                -10 * (M_next - M)))
}

reward <- function(M_next, M, W_next, W, died) {
  R2(W_next, W) +
    R3(M_next, M) +
    ifelse(died == 1, -60, 0)
}

reward_est <- function(M_next, M, W_next, W, pdied) {
  R2(W_next, W) +
    R3(M_next, M) +
    -60 * pdied
}

lambda <- function(W, M, mu0 = -7, mu1 = 1, mu2 = 1) {
  exp(mu0 + mu1 * W + mu2 * M)
}

pDeath <- function(M_next, W_next) {
  lam <- lambda(W_next, M_next)
  deltaF <- exp(-lam)
  1 - deltaF
}

# sim ---------------------------------------------------------------------

simMonth <- function(dat) {
  dat %>%
    mutate(
      M_next = ifelse(!dead, updateM(tumor_mass, toxicity, dose), NA),
      W_next = ifelse(!dead, updateW(tumor_mass, toxicity, dose), NA),
      d_next = runif(nrow(.), min = 0, max = 1),
      died = rbinom(nrow(.), 1, pDeath(M_next, W_next)),
      dead = ifelse(dead, dead, ifelse(died == 1, T, F)),
      reward = reward(
        M_next = M_next,
        M = tumor_mass,
        W = toxicity,
        W_next = W_next,
        died
      )
    )
}

sim <- function(N = 1000, Ttot = 6) {
  dat <- tibble(
    ID = 1:N,
    month = rep(0, N),
    tumor_mass = runif(N, min = 0, max = 2),
    toxicity = runif(N, min = 0, max = 2),
    dose = runif(N, min = 0.5, max = 1),
    dead = rep(F, N)
  ) %>% bind_cols(replicate(10, runif(N, min = 0, max = 1)) %>% as.data.frame())
  d <- simMonth(dat)
  out <- d
  for (i in 1:(Ttot - 1)) {
    d <- d %>% mutate(month = i,
                      tumor_mass = M_next,
                      toxicity = W_next,
                      dose = d_next) %>% simMonth()
    out <- bind_rows(out, d)
  }
  d <- d %>% mutate(month = Ttot,
                    tumor_mass = M_next,
                    toxicity = W_next,
                    dose = NA, died = NA, dead = NA,
                    reward = NA)
  bind_rows(out, d)
}


# best possible -----------------------------------------------------------

maxMonth <- function(dat, len = 101) {
  dat %>% ungroup() %>% 
    mutate(dose = map(1:nrow(.), ~ seq(0, 1, length.out = len))) %>%
    unnest() %>%
    mutate(
      M_next = updateM(tumor_mass, toxicity, dose),
      W_next = updateW(tumor_mass, toxicity, dose),
      pdied = pDeath(M_next, W_next),
      reward = reward_est(
        M_next = M_next,
        M = tumor_mass,
        W = toxicity,
        W_next = W_next,
        pdied
      )
    ) %>% group_by(ID) %>% mutate(
      max = max(reward),
      best = ifelse(near(reward, max), dose, NA),
      best = ifelse(
        tumor_mass > 0,
        max(best, na.rm = T),
        min(best, na.rm = T)
      )
    ) %>% filter(near(dose, best))
}

# sim test refactored -----------------------------------------------------

simMonthT <- function(dat) {
  optimD <- max_df(
    data = filter(dat, group == "optim"),
    model = Q$mod_list[[dat$month[1] + 1]],
    form = Q$formula,
    mod_type = Q$mod_type
  )$best
  
  bestD <- maxMonth(filter(dat, group == "best"))$dose
  
  dat %>%
    mutate(
      M_next = updateM(tumor_mass, toxicity, dose),
      W_next = updateW(tumor_mass, toxicity, dose),
      d_next = ifelse(group == "optim", optimD,
                      ifelse(group == "best", bestD, dose)), 
      pdeath = pDeath(M_next, W_next),
      reward = reward_est(M_next, tumor_mass, W_next, toxicity, pdeath)
    )
}

sim_test <- function(Q, npergroup = 200, ngroups = 12, Ttot = 6) {
  M0 <- runif(npergroup, min = 0, max = 2)
  W0 <- runif(npergroup, min = 0, max = 2)
  V <- replicate(10, runif(npergroup, min = 0, max = 1))
  
  dat <- tibble(
    ID = 1:npergroup,
    month = rep(0, npergroup),
    tumor_mass = M0,
    toxicity = W0,
    dead = rep(F, npergroup)
  ) %>% bind_cols(V %>% as.data.frame())
  
  D1 <- rep(seq(from = 0.1, to = 1, by = 0.1), each = npergroup)
  
  D0 <-
    max_df(
      data = dat,
      model = Q$mod_list[[1]],
      form = Q$formula,
      mod_type = Q$mod_type
    )$best
  
  Dbest <- maxMonth(dat)$dose
  
  groups <- c(
    seq(from = 0.1, to = 1, by = 0.1) %>% as.character(),
    "best",
    "optim")
  
  dat <- dat[rep(seq_len(nrow(dat)), ngroups), ] %>% 
    mutate(
      ID = rep(1:(npergroup * ngroups)),
      group = rep(groups, each = npergroup),
      dose = c(D1, Dbest, D0)
    )
  
  d <- simMonthT(dat)
  out <- d
  for (i in 1:(Ttot - 1)) {
    d <- d %>% mutate(month = i,
                      tumor_mass = M_next,
                      toxicity = W_next,
                      dose = d_next) %>% simMonthT()
    out <- bind_rows(out, d)
  }
  d <- d %>% mutate(month = Ttot,
                    tumor_mass = M_next,
                    toxicity = W_next,
                    dose = NA,
                    reward = NA)
  out <- bind_rows(out, d)
  out %>%
    select(ID, group, month, tumor_mass, toxicity, dose, pdeath, reward) %>%
    group_by(ID) %>%
    mutate(tot_reward = sum(reward, na.rm = T))
}

```

# old sim code
```{r}
# simulation functions ----------------------------------------------------

# function for how toxicity changes
updateW <- function(M, W, D, a1 = 0.1, b1 = 1.2, d1 = 0.5) {
  W_next <- a1 * M + b1 * (D - d1) + W
  ifelse(W_next > 0, W_next, 0)
}

# function for updating tumor mass
updateM <- function(M, W, D, a2 = 0.15, b2 = 1.2, d2 = 0.5) {
  M_next <- ifelse(M > 0,
                   (a2 * W - b2 * (D - d2)) + M,
                   0)
  ifelse(M_next > 0, M_next, 0)
}

updateMint <- function(M, W, D, X, a2 = 0.15, b2 = 1.2, d2 = 0.5) {
  # takes current value of tumor mass, outputs next value
  M_next <- ifelse(M > 0,
                   (a2 * W - b2 * (D * ifelse(X > 0.5, 2, 1) - d2)) + M,
                   0)
  ifelse(M_next > 0, M_next, 0)
}

# reward functions
R2 <- function(W_next, W) {
  -10 * (W_next - W)
}

R3 <- function(M_next, M) {
  ifelse(M_next == 0 & M == 0,
         0,
         ifelse(M_next == 0,
                15,
                -10 * (M_next - M)))
}

reward <- function(M_next, M, W_next, W, died) {
  R2(W_next, W) +
    R3(M_next, M) +
    ifelse(died == 1, -60, 0)
}

reward_est <- function(M_next, M, W_next, W, pdied) {
  R2(W_next, W) +
    R3(M_next, M) +
    -60 * pdied
}

lambda <- function(W, M, mu0 = -7, mu1 = 1, mu2 = 1) {
  exp(mu0 + mu1 * W + mu2 * M)
}

pDeath <- function(M_next, W_next) {
  lam <- lambda(W_next, M_next)
  deltaF <- exp(-lam)
  1 - deltaF
}

# sim ---------------------------------------------------------------------

simMonth <- function(dat, int) {
  if (int) {
    dat <- dat %>%
      mutate(M_next = ifelse(!dead, updateMint(tumor_mass, toxicity, dose, X), NA))
  } else {
    dat <- dat %>%
      mutate(M_next = ifelse(!dead, updateM(tumor_mass, toxicity, dose), NA))
  }
  dat %>% mutate(
    W_next = ifelse(!dead, updateW(tumor_mass, toxicity, dose), NA),
    d_next = runif(nrow(.), min = 0, max = 1),
    died = rbinom(nrow(.), 1, pDeath(M_next, W_next)),
    dead = ifelse(dead,
                  T,
                  ifelse(died == 1, T, F)),
    reward = reward(
      M_next = M_next,
      M = tumor_mass,
      W = toxicity,
      W_next = W_next,
      died
    )
  )
}

sim <- function(N = 1000, Ttot = 6, int = F, noise = F) {
  dat <- tibble(
    ID = 1:N,
    month = rep(0, N),
    tumor_mass = runif(N, min = 0, max = 2),
    toxicity = runif(N, min = 0, max = 2),
    dose = runif(N, min = 0, max = 1),
    dead = rep(F, N)
  )
  if (int) {
    dat <- dat %>%
      mutate(X = runif(N, min = 0, max = 1))
  } else if (noise) {
    dat <- dat %>%
      bind_cols(replicate(10, runif(N, min = 0, max = 1)) %>% as.data.frame())
  }
  d <- simMonth(dat, int = int)
  out <- d
  for (i in 1:(Ttot - 1)) {
    d <- d %>% mutate(month = i,
                      tumor_mass = M_next,
                      toxicity = W_next,
                      dose = d_next) %>% simMonth(int = int)
    out <- bind_rows(out, d)
  }
  d <- d %>% mutate(month = Ttot,
                    tumor_mass = M_next,
                    toxicity = W_next,
                    dose = NA, died = NA, dead = NA,
                    reward = NA)
  bind_rows(out, d)
}

# best possible -----------------------------------------------------------

maxMonth <- function(dat, len = 101, int) {
  dat <- dat %>% ungroup() %>% 
    mutate(dose = map(1:nrow(.), ~ seq(0, 1, length.out = len))) %>%
    unnest()
  if (int) {
    dat <- dat %>%
      mutate(M_next = ifelse(!dead, updateMint(tumor_mass, toxicity, dose, X), NA))
  } else {
    dat <- dat %>%
      mutate(M_next = ifelse(!dead, updateM(tumor_mass, toxicity, dose), NA))
  }
  dat %>% mutate(
    W_next = updateW(tumor_mass, toxicity, dose),
    pdied = pDeath(M_next, W_next),
    reward = reward_est(
      M_next = M_next,
      M = tumor_mass,
      W = toxicity,
      W_next = W_next,
      pdied
    )
  ) %>% group_by(ID) %>% mutate(
    max = max(reward),
    best = ifelse(near(reward, max), dose, NA),
    best = ifelse(
      tumor_mass > 0,
      max(best, na.rm = T),
      min(best, na.rm = T)
    )
  ) %>% filter(near(dose, best))
}

# sim test refactored -----------------------------------------------------

simMonthT <- function(dat, Q, int) {
  optimD <- max_df(
    data = filter(dat, group == "optim"),
    model = Q$mod_list[[dat$month[1] + 1]],
    form = Q$formula,
    mod_type = Q$mod_type
  )$best
  
  bestD <- maxMonth(filter(dat, group == "best"), int = int)$dose
  
  if (int) {
    dat <- dat %>%
      mutate(
        M_next = ifelse(!dead, updateMint(tumor_mass, toxicity, dose, X), NA)
      )
  } else {
    dat <- dat %>%
      mutate(M_next = ifelse(!dead, updateM(tumor_mass, toxicity, dose), NA))
  }
  
  dat %>%
    mutate(
      W_next = updateW(tumor_mass, toxicity, dose),
      d_next = ifelse(group == "optim", optimD,
                      ifelse(group == "best", bestD, dose)), 
      pdeath = pDeath(M_next, W_next),
      reward = reward_est(M_next, tumor_mass, W_next, toxicity, pdeath)
    )
}

sim_test <- function(Q, npergroup = 200, ngroups = 12, Ttot = 6, int = F, noise = F) {
  M0 <- runif(npergroup, min = 0, max = 2)
  W0 <- runif(npergroup, min = 0, max = 2)
  
  dat <- tibble(
    ID = 1:npergroup,
    month = rep(0, npergroup),
    tumor_mass = M0,
    toxicity = W0,
    dead = rep(F, npergroup)
  )
  
  if (int) {
    X <- runif(npergroup, min = 0, max = 1)
    dat <- dat %>%
      mutate(X = X)
  } else if (noise) {
    V <- replicate(10, runif(npergroup, min = 0, max = 1))
    dat <- dat %>% bind_cols(V %>% as.data.frame())
  }
  
  D1 <- rep(seq(from = 0.1, to = 1, by = 0.1), each = npergroup)
  
  D0 <-
    max_df(
      data = dat,
      model = Q$mod_list[[1]],
      form = Q$formula,
      mod_type = Q$mod_type
    )$best
  
  Dbest <- maxMonth(dat, int = int)$dose
  
  groups <- c(
    seq(from = 0.1, to = 1, by = 0.1) %>% as.character(),
    "best",
    "optim")
  
  dat <- dat[rep(seq_len(nrow(dat)), ngroups), ] %>% 
    mutate(
      ID = rep(1:(npergroup * ngroups)),
      group = rep(groups, each = npergroup),
      dose = c(D1, Dbest, D0)
    )
  
  d <- simMonthT(dat, Q, int = int)
  out <- d
  for (i in 1:(Ttot - 1)) {
    d <- d %>% mutate(month = i,
                      tumor_mass = M_next,
                      toxicity = W_next,
                      dose = d_next) %>% simMonthT(Q, int = int)
    out <- bind_rows(out, d)
  }
  d <- d %>% mutate(month = Ttot,
                    tumor_mass = M_next,
                    toxicity = W_next,
                    dose = NA,
                    reward = NA)
  out <- bind_rows(out, d)
  out %>%
    select(ID, group, month, tumor_mass, toxicity, dose, pdeath, reward) %>%
    group_by(ID) %>%
    mutate(tot_reward = sum(reward, na.rm = T))
}
```

# old simulation code

```{r}

sim_test2 <- function(Q) {
  # 200 patients per each of 11 treatments
  N <- 200 
  ngroups <- 12
  # 6 months treatment
  Ttot <- 6 
  
  # The initial values of W0 and M0 for the patients were randomly chosen from the 
  # same uniform distribution used in the training data.
  W0 <- runif(N, min = 0, max = 2)
  M0 <- runif(N, min = 0, max = 2)
  
  # treatments consisting of the estimated optimal treatment regime and each of the 10 possible fixed dose levels ranging from 0.1 to 1.0 with increments of size 0.1.
  D1 <- map(seq(from = 0.1, to = 1, by = 0.1), ~ rep(., N)) %>% flatten_dbl()
  
  # estimate optimal treatment regime for 200
  dat <-
    tibble(
      ID = 1:N,
      toxicity = W0,
      tumor_mass = M0
    )
  
  D0 <-
    max_df(
      data = dat,
      model = Q$mod_list[[1]],
      form = Q$formula,
      mod_type = Q$mod_type
    )$best
  
  Dbest <- maxMonth(dat)$dose
  
  D1 <- c(D1, Dbest, D0)
  
  D <- matrix(rep(D1, Ttot), ncol = Ttot)
  
  num_cells <- N * ngroups * Ttot 
  r <- matrix(c(numeric(num_cells)), ncol = Ttot)
  pdied <- matrix(c(numeric(num_cells)), ncol = Ttot)
  dead <- logical(N * ngroups)
  W <- matrix(c(rep(W0, ngroups), numeric(num_cells)), ncol = Ttot + 1)
  M <- matrix(c(rep(M0, ngroups), numeric(num_cells)), ncol = Ttot + 1)
  
  for (j in 1:(Ttot)) {
    for (i in 1:(N * ngroups)) {
      if (dead[i]) {
        pdied[i, j] <- 0
        M[i, j + 1] <- NA
        W[i, j + 1] <- NA
        r[i, j] <- 0
      } else {
        M[i, j + 1] <- updateM(M[i, j], W[i, j], D[i, j])
        W[i, j + 1] <- updateW(M[i, j], W[i, j], D[i, j])
        pdied[i, j] <- pDeath(M[i, j + 1], W[i, j + 1])
        r[i, j] <- reward_est(
          M[i, j + 1],
          M[i, j],
          W[i, j + 1],
          W[i, j],
          pdied[i , j]
        )
      }
      if (pdied[i, j] == 1) {
        dead[i] <- T
      }
    }
    if (j < Ttot) {
      df <- tibble(
        ID = tail(1:(N * ngroups), 200),
        toxicity = tail(W[, j + 1], 200),
        tumor_mass = tail(M[, j + 1], 200)
      )
      D[df$ID, j + 1] <- max_df(
        data = df,
        model = Q$mod_list[[j + 1]],
        form = Q$formula,
        mod_type = Q$mod_type
      )$best
      df <- tibble(
        ID = tail(1:(N * ngroups), 400) %>% head(200),
        toxicity = tail(W[, j + 1], 400) %>% head(200),
        tumor_mass = tail(M[, j + 1], 400) %>% head(200)
      )
      D[df$ID, j + 1] <- maxMonth(df)$dose
    }
  }
  
  colnames(D) <- 0:5
  colnames(M) <- 0:6
  colnames(W) <- 0:6
  colnames(r) <- 0:5
  colnames(pdied) <- 1:6
  dat_test <-
    data.frame(
      D = D,
      M = M,
      W = W,
      r = r,
      d = died
    ) %>% tbl_df()
  
  dat_test <- dat_test %>%
    rownames_to_column(var = "ID") %>%
    mutate(ID = as.numeric(ID),
           group = ifelse(ID < 2201, 
                          ifelse(ID > 2000, "best", D1), "optim"),
           group = factor(group))
  
  dat_test <- dat_test %>%
    gather(key, value, -ID, -group) %>%
    extract(col = key,
            into = c("var", "month"),
            regex = "(.)\\.(.)") %>%
    mutate(month = as.numeric(month)) %>%
    spread(var, value) %>%
    select(
      ID,
      month,
      group,
      dose = D,
      tumor_mass = M,
      toxicity = W,
      reward = r,
      died = d
    ) %>% group_by(ID) %>% mutate(
      tot_reward = sum(reward, na.rm = T)
    )
  dat_test
}
```


# older simulation code

```{r, eval=FALSE, include=FALSE}
zeroRewards <- function(x, died = died, i) {
  # zeroR function zeros rewards after death of a patient
  # inputs:
  #   matrix of total rewards (r)
  #   matrix of deaths (died)
  #   an index of a particular patient of interest (i)
  # returns:
  #   row vector of rewards for the patient with rewards following death = 0
  if (sum(died[i, ]) >= 1) {
    first <- which(died[i, ] == 1)[1]
    if (first < ncol(died)) {x[i, (first + 1):ncol(died)] <- 0}
    return(x[i, ])
  }
  return(x[i, ])
}

makeNA <- function(x, died = died, i) {
  # NAs values after death of a patient
  # inputs:
  #   matrix of total rewards (r)
  #   matrix of deaths (died)
  #   an index of a particular patient of interest (i)
  # returns:
  #   row vector of rewards for the patient with rewards following death = 0
  if (sum(died[i, ]) >= 1) {
    first <- which(died[i, ] == 1)[1]
    if (first < ncol(died)) {x[i, (first + 1):ncol(died)] <- NA}
    return(x[i, ])
  }
  return(x[i, ])
}

for (i in 1:nrow(r)) {
  r[i, ] <- zeroRewards(r, died, i)
}




set.seed(5)
died <- apply(p, c(1, 2), function(p) rbinom(1, 1, p))
r1 <- ifelse(died == 1, -60, 0)



r <- r1 + r2 + r3



p <- 1 - deltaF



lams <- matrix(numeric(6000), ncol = 6)
for (i in 1:(Ttot)) {
  lams[, i] <- lambda(W[, i + 1], M[, i + 1], mu0, mu1, mu2)
}
deltaF <- exp(-lams)




mu0 <- -7 ### MADE UP. NO VALUE GIVEN IN TEXT
mu1 <- 1
mu2 <- 1





lambda <- function(W, M, mu0, mu1, mu2) {
  exp(mu0 + mu1 * W + mu2 * M)
}



R2 <- function(W1, W0) {
  ifelse(W1 - W0 <= -0.5, 5,
         ifelse(W1 - W0 >= 0.5, -5, 0))
}

R3 <- function(M1, M0) {
  ifelse(M1 == 0 & M0 == 0, 0,
         ifelse(M1 == 0, 15,
                ifelse(M1 - M0 <= -0.5, 5,
                       ifelse(M1 - M0 >= 0.5, -5, 0)))
  )
}

r2 <- matrix(c(numeric(6000)), ncol = 6)
r3 <- matrix(c(numeric(6000)), ncol = 6)
for (i in 1:(Ttot)) {
  r2[, i] <- R2(W[, i + 1], W[, i])
  r3[, i] <- R3(M[, i + 1], M[, i])
}



a1 <- 0.1
a2 <- 0.15
b1 <- 1.2
b2 <- 1.2
d1 <- 0.5
d2 <- 0.5



W <- matrix(c(W0, numeric(6000)), ncol = 7)
M <- matrix(c(M0, numeric(6000)), ncol = 7)

for (i in 1:(Ttot)) {
  M_next <- ifelse(M[, i] == 0, 0, Mdot(M[, i], W[, i], D[, i]) + W[, i])
  W_next <- Wdot(M[, i], D[, i]) + W[, i]
  W[, i + 1] <- ifelse(W_next <= 0, 0, W_next)
  M[, i + 1] <- ifelse(M_next <= 0, 0, M_next)
}




Mdot <- function(M, W, D, a2 = 0.15, b2 = 1.2, d2 = 0.5) {
  (a2 * W - b2 * (D - d2)) * ifelse(M > 0, 1, 0)
}


Wdot <- function(M, D, a1 = 0.1, b1 = 1.2, d1 = 0.5) {
  a1 * M + b1 * (D - d1)
}



set.seed(4)
D <- replicate(5, runif(N, min = 0, max = 1))

D <- cbind(D0, D)



set.seed(3)
D0 <- runif(N, min = 0.5, max = 1)



set.seed(2)
M0 <- runif(N, min = 0, max = 2)



set.seed(1)
W0 <- runif(N, min = 0, max = 2)



Ttot <- 6



N <- 1000



colnames(D) <- 0:5
colnames(M) <- 0:6
colnames(W) <- 0:6
colnames(r) <- 0:5
colnames(died) <- 0:5
dat <- data.frame(D = D, M = M, W = W, r = r, d = died) %>% tbl_df() %>%
  rownames_to_column(var = "ID") %>% mutate(ID = factor(ID))

dat_long <- dat %>%
  gather(key, value, -ID) %>%
  extract(col = key,
          into = c("var", "month"),
          regex = "(.)\\.(.)") %>%
  spread(var, value) %>%
  select(
    ID,
    month,
    dose = D,
    tumor_mass = M,
    toxicity = W,
    reward = r,
    died = d
  )
View(dat_long)

dat <- dat %>%
  mutate(month = as.character(0:end_month) %>% str_c(., collapse = ".")) %>%
  separate(month, into = as.character(0:end_month)) %>%
  gather(month, z, convert = T, -id) %>%
  select(-z) %>% arrange(id)

# choose initial dose of 0.5 or more
d0 = runif(1, min = 0.5, max = 1),
# choose any subsequent dose


mtcars %>%
  split(.$cyl) %>%
  map(~ lm(mpg ~ wt, data = .)) %>%
  map(summary) %>%
  map_dbl("r.squared")

dat %>%
  split(.$id) %>%
  map_df(f)

f <- function(x) {
  x = x
  tibble(
    n = list(1, 5),
    min = list(0.5, 0),
    max = list(1, 1)
  ) %>% pmap(runif) %>% flatten_dbl()
}



dat %>% mutate_(.dots= setNames(list(varval), col))

l <- tibble(
  n = list(1, 5),
  min = list(0.5, 0),
  max = list(1, 1)
) %>% pmap(runif) %>% flatten_dbl()

l

multipetal <- function(df, n) {
  varname <- paste("petal", n , sep=".")
  df[[varname]] <- with(df, Petal.Width * n)
  df
}

multipetal <- function(df, n) {
  varname <- str_c("petal", n, sep=".")
  varval <- lazyeval::interp(~Petal.Width * n, n=n)
  mutate_(df, .dots= setNames(list(varval), varname))
}

for (i in 1:(Ttot)) {
  M_next <- ifelse(M[, i] == 0, 0, Wdot(M[, i], D[, i]) + W[, i])
  W_next <- Wdot(M[, i], D[, i]) + W[, i]
  W[, i + 1] <- ifelse(W_next <= 0, 0, W_next)
  M[, i + 1] <- ifelse(M_next <= 0, 0, M_next)
  r2[, i] <- R2(W[, i + 1], W[, i])
  r3[, i] <- R3(M[, i + 1], M[, i])
  lams[, i] <- lambda(W[, i + 1], M[, i + 1], mu0, mu1, mu2)
  p <- 1 - deltaF
}
```


# simulation code v2 not wrapped in function

```{r, eval=FALSE, include=FALSE}
# 1000 patients
N <- 1000
# 6 months treatment
Ttot <- 6 

# choose random initial toxicities and tumor masses
set.seed(1)
W0 <- runif(N, min = 0, max = 2)
M0 <- runif(N, min = 0, max = 2)

# choose random starting dose > 0.5
D0 <- runif(N, min = 0.5, max = 1)
# choose random subsequent doses between 0 and 1 (max tolerable)
D <- replicate(5, runif(N, min = 0, max = 1))
D <- cbind(D0, D)

# function for how toxicity changes
Wdot <- function(M, D, a1 = 0.1, b1 = 1.2, d1 = 0.5) { 
  a1 * M + b1 * (D - d1)
}

# function for how tumor mass changes
Mdot <- function(M, W, D, a2 = 0.15, b2 = 1.2, d2 = 0.5) { 
  (a2 * W - b2 * (D - d2)) * ifelse(M > 0, 1, 0)
}

# reward functions
R2 <- function(W1, W0) {
  ifelse(W1 - W0 <= -0.5, 5,
         ifelse(W1 - W0 >= 0.5, -5, 0))
}

R3 <- function(M1, M0) {
  ifelse(M1 == 0 & M0 == 0, 0,
         ifelse(M1 == 0, 15,
                ifelse(M1 - M0 <= -0.5, 5,
                       ifelse(M1 - M0 >= 0.5, -5, 0)))
  )
}

lambda <- function(W, M, mu0 = -7, mu1 = 1, mu2 = 1) {
  exp(mu0 + mu1 * W + mu2 * M)
}

r <- matrix(c(numeric(6000)), ncol = 6)
died <- matrix(c(numeric(6000)), ncol = 6)
W <- matrix(c(W0, numeric(6000)), ncol = 7)
M <- matrix(c(M0, numeric(6000)), ncol = 7)

for (i in 1:(Ttot)) {
  for (j in 1:N) {
    if (sum(died[j, 1:i]) == 0) {
      M_next <- ifelse(M[j, i] == 0, # if patient cured (tumor mass == 0)
                       0, # mass stays 0
                       Mdot(M[j, i], W[j, i], D[j, i]) + M[j, i]) # otherwise find next mass
      W_next <- Wdot(M[j, i], D[j, i]) + W[j, i]
      # mass and toxicity bounded at 0
      W[j, i + 1] <- ifelse(W_next <= 0,
                            0,
                            W_next)
      M[j, i + 1] <- ifelse(M_next <= 0,
                            0,
                            M_next)
      # determine if patient died
      lam <- lambda(W[j, i + 1], M[j, i + 1])
      deltaF <- exp(-lam)
      p <- 1 - deltaF
      died[j, i] <- rbinom(1, 1, p)
      # add up rewards
      r[j, i] <-
        R2(W[j, i + 1], W[j, i]) +
        R3(M[j, i + 1], M[j, i]) +
        ifelse(died[j, i] == 1, -60, 0)
    } else {
      # if patient already died, can't die again or get rewards, mass and tox to NA
      r[j, i] <- 0
      if (i != Ttot) {
        died[j, i + 1] <- 0
      } else {died[j, i] <- 0}
      M[j, i + 1] <- NA
      W[j, i + 1] <- NA
    }
  }
}

colnames(D) <- 0:5
colnames(M) <- 0:6
colnames(W) <- 0:6
colnames(r) <- 0:5
colnames(died) <- 1:6
# colnames(noise) <- 0:6
dat <- data.frame(D = D, M = M, W = W, r = r, d = died) %>% tbl_df() %>% 
  rownames_to_column(var = "ID") %>% mutate(ID = as.numeric(ID))

dat_long <- dat %>%
  gather(key, value, -ID) %>%
  extract(col = key,
          into = c("var", "month"),
          regex = "(.)\\.(.)") %>%
  spread(var, value) %>%
  select(
    ID,
    month,
    dose = D,
    tumor_mass = M,
    toxicity = W,
    reward = r,
    died = d
  )

```



# simulation code v3 

```{r}
# simulation functions ----------------------------------------------------

# function for how toxicity changes
updateW <- function(M, W, D, a1 = 0.1, b1 = 1.2, d1 = 0.5) { 
  W_next <- a1 * M + b1 * (D - d1) + W
  W_next
  # ifelse(W_next > 0, W_next, 0)
}

# function for updating tumor mass
updateM <- function(M, W, D, a2 = 0.15, b2 = 1.2, d2 = 0.5) {
  # takes current value of tumor mass, outputs next value
  if (M > 0) {
    Mdot <- (a2 * W - b2 * (D - d2))
    ifelse(Mdot + M > 0, Mdot + M, 0)
  } else {
    0
  }
}

# reward functions
R2 <- function(W_next, W) {
   dW <- W_next - W
   if (dW <= -0.5) {
     5
   } else if (dW > 0.5) {
     -5
   } else {
     0
   }
}

R3 <- function(M_next, M) {
  if (M_next == 0 & M == 0) {
    0
  } else if (M_next == 0) {
    15
  } else {
    dM <- M_next - M
    if (dM <= -0.5) {
      5
    } else if (dM > 0.5) {
      -5
    } else {
      0
    }
  }
}

reward <- function(M_next, M, W_next, W, died) {
  R2(W_next, W) +
    R3(M_next, M) +
    ifelse(died == 1, -60, 0)
}

lambda <- function(W, M, mu0 = -7, mu1 = 1, mu2 = 1) {
  exp(mu0 + mu1 * W + mu2 * M)
}

determineDeath <- function(M_next, W_next) {
  lam <- lambda(W_next, M_next)
  deltaF <- exp(-lam)
  p <- 1 - deltaF
  return(rbinom(1, 1, p))
}

sim <- function(N = 1000, Ttot = 6) {
  # 1000 patients, 6 months treatment
  
  # choose random initial toxicities and tumor masses
  W0 <- runif(N, min = 0, max = 2)
  M0 <- runif(N, min = 0, max = 2)
  
  # choose random starting dose > 0.5
  D0 <- runif(N, min = 0.5, max = 1)
  # choose random subsequent doses between 0 and 1 (max tolerable)
  D <- replicate(Ttot - 1, runif(N, min = 0, max = 1))
  D <- cbind(D0, D)
  
  r <- matrix(c(numeric(N * Ttot)), ncol = 6)
  died <- matrix(c(numeric(N * Ttot)), ncol = 6)
  dead <- logical(N)
  W <- matrix(c(W0, numeric(N * Ttot)), ncol = 7)
  M <- matrix(c(M0, numeric(N * Ttot)), ncol = 7)
  
  for (j in 1:Ttot) {
    for (i in 1:N) {
      if (dead[i]) {
        died[i, j] <- 0 
        M[i, j + 1] <- NA
        W[i, j + 1] <- NA
        r[i, j] <- 0
      } else {
        M[i, j + 1] <- updateM(M[i, j], W[i, j], D[i, j])
        W[i, j + 1] <- updateW(M[i, j], W[i, j], D[i, j])
        died[i, j] <- determineDeath(M[i, j + 1], W[i, j + 1])
        r[i, j] <- reward(M[i, j + 1],
                          M[i, j],
                          W[i, j + 1],
                          W[i, j],
                          died[i , j])
      }
      if (died[i, j] == 1) {dead[i] <- T}
    }
  }
  
  
  colnames(D) <- 0:5
  colnames(M) <- 0:6
  colnames(W) <- 0:6
  colnames(r) <- 0:5
  colnames(died) <- 1:6
  # colnames(noise) <- 0:6
  dat <- data.frame(D = D, M = M, W = W, r = r, d = died) %>% tbl_df() %>% 
    rownames_to_column(var = "ID") %>% mutate(ID = as.numeric(ID))
  
  dat %>%
    gather(key, value, -ID) %>%
    extract(col = key,
            into = c("var", "month"),
            regex = "(.)\\.(.)") %>%
    spread(var, value) %>%
    select(
      ID,
      month,
      dose = D,
      tumor_mass = M,
      toxicity = W,
      reward = r,
      died = d
    )
}


# sim testing function ----------------------------------------------------

sim_test <- function(Q) {
  # 200 patients per each of 11 treatments
  N <- 200 * 11
  # 6 months treatment
  Ttot <- 6 
  
  # The initial values of W0 and M0 for the patients were randomly chosen from the 
  # same uniform distribution used in the training data.
  set.seed(5)
  W0 <- runif(N, min = 0, max = 2)
  M0 <- runif(N, min = 0, max = 2)
  
  # treatments consisting of the estimated optimal treatment regime and each of the 10 possible fixed dose levels ranging from 0.1 to 1.0 with increments of size 0.1.
  D1 <- map(seq(from = 0.1, to = 1, by = 0.1), ~ rep(., 200)) %>% flatten_dbl()
  
  # estimate optimal treatment regime for 200
  dat <-
    tibble(
      ID = tail(1:N, 200),
      toxicity = tail(W0, 200),
      tumor_mass = tail(M0, 200)
    )
  
  D0 <-
    max_df(
      data = dat,
      model = Q$mod_list[[1]],
      form = Q$formula,
      idvar = "ID",
      mod_type = Q$mod_type
    )$best
  
  D1 <- c(D1, D0)
  
  D <- replicate(6, D1)
  
  r <- matrix(c(numeric(N * Ttot)), ncol = Ttot)
  died <- matrix(c(numeric(N * Ttot)), ncol = Ttot)
  dead <- logical(N)
  W <- matrix(c(W0, numeric(N * Ttot)), ncol = Ttot + 1)
  M <- matrix(c(M0, numeric(N * Ttot)), ncol = Ttot + 1)
  
  for (j in 1:Ttot) {
    for (i in 1:N) {
      if (dead[i]) {
        died[i, j] <- 0
        M[i, j + 1] <- NA
        W[i, j + 1] <- NA
        r[i, j] <- 0
      } else {
        M[i, j + 1] <- updateM(M[i, j], W[i, j], D[i, j])
        W[i, j + 1] <- updateW(M[i, j], W[i, j], D[i, j])
        died[i, j] <- determineDeath(M[i, j + 1], W[i, j + 1])
        r[i, j] <- reward(M[i, j + 1],
                          M[i, j],
                          W[i, j + 1],
                          W[i, j],
                          died[i , j])
      }
      if (died[i, j] == 1) {
        dead[i] <- T
      }
    }
    if (j < Ttot) {
      df <- tibble(
        ID = tail(1:N, 200),
        toxicity = tail(W[, j + 1], 200),
        tumor_mass = tail(M[, j + 1], 200)
      )
      D[df$ID, j + 1] <- max_df(
        data = df,
        model = Q$mod_list[[j]],
        form = Q$formula,
        mod_type = Q$mod_type
      )$best
    }
  }
  
  colnames(D) <- 0:5
  colnames(M) <- 0:6
  colnames(W) <- 0:6
  colnames(r) <- 0:5
  colnames(died) <- 1:6
  dat_test <-
    data.frame(
      D = D,
      M = M,
      W = W,
      r = r,
      d = died
    ) %>% tbl_df()
  
  dat_test <- dat_test %>%
    rownames_to_column(var = "ID") %>%
    mutate(ID = as.numeric(ID),
           group = ifelse(ID < 2001, D1, "optim"),
           group = factor(group))
  
  dat_test <- dat_test %>%
    gather(key, value, -ID, -group) %>%
    extract(col = key,
            into = c("var", "month"),
            regex = "(.)\\.(.)") %>%
    spread(var, value) %>%
    select(
      ID,
      month,
      group,
      dose = D,
      tumor_mass = M,
      toxicity = W,
      reward = r,
      died = d
    ) %>% group_by(ID) %>% mutate(
      tot_reward = sum(reward, na.rm = T)
    )
}
```


# old rpart testing 

```{r, eval=FALSE, include=FALSE}
p_load(rpart, rpart.plot, caret)
dat_long <- dat_long %>% mutate(
  Q_hat = ifelse(month == 6, NA,
                 ifelse(month == 5, reward, 0)),
  Q_hat = ifelse(Q_hat == -65, -60, Q_hat) %>% factor(),
  best = ifelse(month == 6, NA, 999)
)

dat_long$Q_hat %>% plot()

parameter <-
  rpart.control(
    # minsplit = 10,
    minbucket = 5,
    xval = 20,
    cp = 1e-6
  )

month5 <- dat_long %>% filter(month == 5)

set.seed(20161105)
pruned <- fit_rpart(Q_hat ~ tumor_mass + toxicity + dose, control = parameter,
                    data = mutate(month5, Q_hat = factor(Q_hat)))

mod_rpart <- rpart(Q_hat ~ tumor_mass + toxicity + dose,
                   control = parameter,
                   data = month5)

printcp(mod_rpart)
plotcp(mod_rpart)

pruned_min_sd <- mod_rpart$cptable %>%
  as_data_frame() %>%
  mutate(
    xerror_min = min(xerror),
    xerror_min_sd = ifelse(xerror == xerror_min, xstd, 0) %>% sum(na.rm = T)
  ) %>% filter(near(xerror, xerror_min + xerror_min_sd, tol = 0.01)) %>%
  filter(nsplit == min(nsplit)) %>% 
  select(CP) %>% flatten_dbl() %>%
  prune(mod_rpart, .)

pruned_min <- mod_rpart$cptable %>%
  as_data_frame() %>%
  filter(xerror == min(xerror)) %>% 
  filter(nsplit == min(nsplit)) %>% 
  select(CP) %>% flatten_dbl() %>%
  prune(mod_rpart, .)

prp(pruned_min)

# predict(pruned_min)[1, ] %>% which.max() %>% names() 

# by_row(as_data_frame(predict(pruned_min)), ~ which.max(.) %>% names() %>% as.numeric(), .to = "preds") %>% unnest() %>% select(preds)

predict(pruned_min) %>% apply(1, function(x) factor(names(which.max(x))))

mod <- pruned

month5 %>%
  select(ID, tumor_mass, toxicity, -dose) %>%
  mutate(dose = map(1:nrow(.), ~ seq(0, 1, 0.01))) %>%
  unnest() %>%
  mutate(preds = predict(mod, .) %>% apply(1, function(x) as.numeric(names(which.max(x))))) %>%
  group_by(ID) %>%
  mutate(max = max(preds),
         best = ifelse(is.na(max),
                       NA,
                       which.max(preds) - 1) / 100) %>%
  select(-dose, -preds) %>% unique()


# testing -----------------------------------------------------------------

# data <- dat_long %>% filter(month == 5) %>% mutate(Q_hat = factor(Q_hat))
# formula <- Q_hat ~ tumor_mass + dose + toxicity
# method <- "rcs"
# treatment <- "dose"
# model <- fit_rpart(form$formula, data = data)
# form <- makeRCS(formula = formula, treatment = "dose", method = "rpart")
# idvar <- "ID"
# method = "rpart"
# x <- seq(0,1,0.01)
# max_df(data = data, model = model, form, method = "rpart")
# 
# if (is.null(idvar)) {
#   data <- data %>% mutate(ID = 1:nrow(.))
#   idvar <- "ID"
# }
# data_long <- data %>%
#   select(matches(idvar),
#          one_of(form$covariates)) %>%
#   mutate(dose = map(1:nrow(.), ~ x)) %>%
#   unnest() 
# if (method == "rcs") {
#   data_preds <- data_long %>%
#     mutate(preds = predict(model, .))
# }
# if (method == "rpart") {
#   data_preds <- data_long %>%
#     mutate(preds = predict(model, .) %>%
#              apply(1, function(x) as.numeric(names(which.max(x)))))
# }
# 
# predict(model, data_long)
# 
# 
# data_preds %>%
#   group_by_(idvar) %>%
#   mutate(max = max(preds),
#          best = ifelse(is.na(max),
#                        NA,
#                        which.max(preds) - 1) / 100) %>%
#   select(-dose, -preds) %>% unique()


# 
# # Q1 <- one_step_Q(
# #   Q_hat ~ noise + tumor_mass + dose + toxicity,
# #   data = mutate(dat_long, noise = runif(7000), Q_hat = reward) %>% filter(month == 5),
# #   treatment = "dose"
# # )
# 
#   form_char <- as.character(formula)
#   response <- form_char[2]
#   predictors <- form_char[3]
#   predictor_names <- strsplit(predictors, " \\+ ")[[1]]
#   if (method == "rcs") {
#     form_base_rcs <- paste(response,
#                            "~",
#                            paste0("rcs(", predictor_names, ")", collapse = " + "))
#     ints <-
#       paste0("rcs(", predictor_names, ")", " %ia% ", "rcs(", treatment, ")")
#     trtbytrt <-
#       paste0("rcs(", treatment, ")", " %ia% ", "rcs(", treatment, ")")
#     ints <- ints[ints != trtbytrt]
#     ints <- paste(ints, collapse = " + ")
#     formula <- paste(c(form_base_rcs, ints), collapse = " + ")
#   }
#   covariates <- predictor_names[!(predictor_names %in% treatment)]
#   list(formula = as.formula(formula), covariates = covariates, treatment = treatment)
# 
# data %>%
#   select(matches(idvar),
#          one_of(form$covariates)) %>%
#   mutate(dose = map(1:nrow(.), ~ x)) %>%
#   unnest() %>%
#   mutate(preds = predict(model, .)) %>%
#   group_by_(idvar) %>%
#   mutate(max = max(preds),
#          best = ifelse(is.na(max),
#                        NA,
#                        which.max(preds) - 1) / 100) %>%
#   select(-dose, -preds) %>% unique()
```


# DTRlearn-qlearn-function

```{r, eval=FALSE, include=FALSE}
library(DTRlearn)

# examples from crt-simulation.rmd (need to run that first)
# to walk through function and see what it's doing
H <- cbind(M[, 6], W[, 6])
R <- r[, 6]
A <- ifelse(D[, 6] >= 0.5, 1, -1) # dichotimize treatment so it plays nice with the function

qlearn <- Qlearning_Single(H, A, R, pentype = "lasso", m = 4)

# Complete funciton (comments mine)
Qlearn_Single <- function(H, A, R, pentype = "lasso", m = 4) 
{
  # H is matrix of state variables
  # A is a vector of actions
  # R is a vector of rewards
  # pentype is estimation (either "lasso" or "LSE" - for ordinary least squares)
  # m is number of folds of cross validation in lasso
  
  n = length(A)
  
  # Create a matrix with the state variables, action variable
  # (in this case treatment: 1 or -1), and the state variables again
  # but negative for those who were in -1 group (control?)
  X = cbind(H, A, diag(A) %*% H) # matrix with H, A, -H for those in -1 group
  
  # estimate coefficients for the above
  if (pentype == "lasso") {
    cvfit = cv.glmnet(X, R, nfolds = m)
    co = as.matrix(predict(cvfit, s = "lambda.min", type = "coeff"))
  }
  else if (pentype == "LSE") {
    co = coef(lm(R ~ X))
  }
  else stop(gettextf("'pentype' is the penalization type for the regression step of Olearning, the default is 'lasso',\nit can also be 'LSE' without penalization"))
  
  # Create two matrices
  # one with a vector of ones (treatment) then state vars twice in a row 
  XX1 = cbind(rep(1, n), H, rep(1, n), H)
  # and another which is the same, but the second repeat is negative (not on treatment)
  XX2 = cbind(rep(1, n), H, rep(-1, n), -H)
  # estimate rewards from each matrix just created
  Q1 = XX1 %*% co
  Q2 = XX2 %*% co
  # figure out which matrix gives largest rewards
  Q = apply(cbind(Q1, Q2), 1, max)
  # return the coefficients and the vector of largest rewards
  Qsingle = list(co = co, Q = Q)
  class(Qsingle) = "qlearn"
  Qsingle
}

#### DTRlearn package ####
X <- list()
for (i in 1:(ncol(M) - 1)) {
  X[[i]] <- cbind(M[, i], W[, i])
}
D_df <- data.frame(D)
r_df <- data.frame(r)

# install.packages("DTRlearn")
library(DTRlearn)
Q <- Qlearning(X = X, AA = D_df, RR = r_df, K = 6, pentype = "lasso", m = 4)
plot.qlearn(Q[[1]])
preds <- predict.qlearn(Q[[1]], X[[1]])

# The optimal treatment option is the the sign of the interaction term
# which maximize the predicted value from the regression model.

# Not sure this really helps'

```


# rpart user defined

```{r, eval=FALSE, include=FALSE}
# initialization function

itemp <- function(y, offset, parms, wt) {
  if (is.matrix(y) && ncol(y) > 1)
    stop("Matrix response not allowed")
  if (!missing(parms) && length(parms) > 0)
    warning("parameter argument ignored")
  if (length(offset))
    y <- y - offset
  sfun <- function(yval, dev, wt, ylevel, digits) {
    paste(" mean=",
          format(signif(yval, digits)),
          ", MSE=" ,
          format(signif(dev / wt, digits)),
          sep = '')
  }
  environment(sfun) <- .GlobalEnv
  list(
    y = c(y),
    parms = NULL,
    numresp = 1,
    numy = 1,
    summary = sfun
  )
}

# evaluation function
etemp <- function(y, wt, parms) {
  wmean <- sum(y * wt) / sum(wt)
  rss <- sum(wt * (y - wmean) ^ 2)
  list(label = wmean, deviance = rss)
}


# splitting function 
stemp <- function(y, wt, x, parms, continuous)
{
  # Center y
  n <- length(y)
  y <- y - sum(y * wt) / sum(wt)
  if (continuous) {
    # continuous x variable
    temp <- cumsum(y * wt)[-n]
    left.wt  <- cumsum(wt)[-n]
    right.wt <- sum(wt) - left.wt
    lmean <- temp / left.wt
    rmean <- -temp / right.wt
    goodness <- (left.wt * lmean ^ 2 + right.wt * rmean ^ 2) / sum(wt * y ^ 2)
    list(goodness = goodness, direction = sign(lmean))
  } else {
    # Categorical X variable
    ux <- sort(unique(x))
    wtsum <- tapply(wt, x, sum)
    ysum  <- tapply(y * wt, x, sum)
    means <- ysum / wtsum
    
    # For anova splits, we can order the categories by their means
    #  then use the same code as for a non-categorical
    ord <- order(means)
    n <- length(ord)
    temp <- cumsum(ysum[ord])[-n]
    left.wt  <- cumsum(wtsum[ord])[-n]
    right.wt <- sum(wt) - left.wt
    lmean <- temp / left.wt
    rmean <- -temp / right.wt
    list(
      goodness = (left.wt * lmean ^ 2 + right.wt * rmean ^ 2) / sum(wt * y ^ 2),
      direction = ux[ord]
    )
  }
}

library(rpart)
mystate <- data.frame(state.x77, region = state.region)
names(mystate) <- casefold(names(mystate)) # remove mixed case
ulist <- list(eval = etemp, split = stemp, init = itemp)
fit1 <- rpart(
  murder ~ population + illiteracy + income + life.exp +
    hs.grad + frost + region,
  data = mystate,
  method = ulist,
  minsplit = 10
)
fit2 <- rpart(
  murder ~ population + illiteracy + income + life.exp +
    hs.grad + frost + region,
  data = mystate,
  method = 'anova',
  minsplit = 10,
  xval = 0
) 

all.equal(fit1$frame, fit2$frame)

all.equal(fit1$splits, fit2$splits)

all.equal(fit1$csplit, fit2$csplit)

all.equal(fit1$where, fit2$where)

all.equal(fit1$cptable, fit2$cptable)
```


# Quint example code from package

```{r, eval=FALSE, include=FALSE}
library(quint)
data("bcrp")
head(bcrp)
# help(bcrp)

ex_data <- subset(bcrp, cond < 3)

formula_dep <- I(cesdt1 - cesdt3) ~ cond | cesdt1 + negsoct1 + uncomt1 + disopt1 + comorbid + age + wcht1 + nationality + marital + trext

formula_phys <- I(physt3 - physt1) ~ cond | cesdt1 + negsoct1 + uncomt1 + disopt1 + comorbid + age + wcht1 + nationality + marital + trext

# Uisng default values for tuning parameters

set.seed(47)
quint1 <- quint(formula_dep, data = ex_data)

summary(quint1)

quint1$fi # fit information
quint1$si # split information
quint1$li # leaf information

quint1pr <- prune(quint1) # does 1 se pruning

plot(quint1pr)

round(quint1pr$li, digits = 2)

set.seed(48)
quint2 <- quint(formula_phys, data = ex_data)

round(quint2$li, digits = 2)
plot(quint2)


# use difference in means instead of effect size
control3 <- quint.control(crit = "dm") 

set.seed(48)
quint3 <- quint(formula = formula_phys, data = ex_data, control = control3)
# same as before

# stop at two leaves
control4 <- quint.control(maxl = 2)

set.seed(48)
quint4 <- quint(formula_dep, data = ex_data, control = control4)
round(quint4$li, digits = 2)


# increase d_min because of small sample size
control5 <- quint.control(crit = "dm", dmin = 0.40)
set.seed(48)
quint5 <- quint(formula = formula_phys, data = ex_data, control = control5)
```


# QUINT
```{r, eval=FALSE, include=FALSE}
library(quint)

#### applied to our data ####

source("~/Google Drive/active/setup.R")
p_load(gridExtra, rpart, quint)

source("./code/sim2.R")
set.seed(20161116)
dat_long <- sim()

# subset only to last month, remove people who have died
dat <- dat_long %>% filter(month == 1 & !is.na(tumor_mass)) %>% mutate(
  dose_cat = ifelse(dose < 0.5, "low", "high") %>% as.factor())

set.seed(20170102)

quint1 <- quint(reward ~ dose_cat | tumor_mass + toxicity + X, data = dat,
                control = quint.control(B = 5))
quint1 %>% summary()
quint1 %>% plot()

q1_p <- prune(quint1)
q1_p %>% summary() 
q1_p %>% plot()

dat2 <- dat_long %>% filter(month == 2 & !is.na(tumor_mass)) %>% mutate(
  dose_cat = ifelse(dose < 0.5, "low", "high") %>% as.factor())

set.seed(20170120)

quint2 <- quint(reward ~ dose_cat | tumor_mass + toxicity + X, data = dat2,
                control = quint.control(B = 5))
quint2 %>% summary()
quint2 %>% plot()

```


# optim
```{r, eval=FALSE, include=FALSE}
dose <- numeric(200)
reward <- numeric(200)
for (i in 1:200) {
  f <- function(x) {
    predict(mod, data.frame(dat, dose = x)[i, ])
  }
  opt <- optimize(f, interval = c(0,1), tol = 0.01, maximum = T)
  dose[i] <- opt$maximum
  reward[i] <- opt$objective
}

x <- seq(0, 1, by = 0.01)
dat %>%
  mutate(dose = map(1:nrow(.), ~ x)) %>%
  unnest() %>%
  mutate(preds = predict(mod, .)) %>%
  group_by(ID) %>%
  mutate(max = max(preds),
         best = ifelse(is.na(max),
                       NA,
                       which.max(preds) - 1) / 100) %>%
  select(-dose, -preds) %>% unique()

```

# ranger rf 
```{r, eval=FALSE, include=FALSE}
# ranger rf ---------------------------------------------------------------

rm(list = ls())
library(pacman)
p_load(tidyverse, ranger)

source("./code/sim2.R")
set.seed(20161116)
dat_long <- sim()

# subset only to last month, remove people who have died
dat <- dat_long %>% filter(month == 5) %>% select(ID, reward, tumor_mass, toxicity, X, dose) 

mod1 <- ranger(reward ~ dose + tumor_mass + toxicity + X, data = na.omit(dat), always.split.variables = "dose")

predictions(mod1, na.omit(dat))


x = seq(0, 1, 0.01)
idvar = "ID"
model = mod1
data <- dat
form <- makeRCS(Q_hat ~ tumor_mass + toxicity + X + dose, "dose", method = "mars")
data_long <- data %>%
  select(matches(idvar),
         one_of(form$covariates)) %>%
  mutate(dose = map(1:nrow(.), ~ x)) %>%
  unnest() 
data_preds <- data_long %>%
  mutate(preds = ifelse(
    !is.na(tumor_mass),
    predict(model, data_long %>% na.omit()) %>% predictions(),
    0
  )) %>%
  group_by_(idvar) %>%
  mutate(max = max(preds),
         best = (which.max(preds) - 1) / 100) 


predictions(predict(model, na.omit(data_long)))

dat_long <- dat_long %>% mutate(
  Q_hat = ifelse(month == 6, NA,
                 ifelse(month == 5, reward, 0)),
  best = ifelse(month == 6, NA, 999)
)
source("./code/qlearn-functs.R")
Q <- Qlearn(dat_long, Q_hat ~ tumor_mass + toxicity + X + dose, "dose", method = "ranger")

```

# RCS with one noise var
```{r, eval=FALSE, include=FALSE}
set.seed(20161027)
dat <- dat_long %>% mutate(
  noise = runif(7000),
  Q_hat = ifelse(month == 6, NA,
                 ifelse(month == 5, reward, 0)),
  best = ifelse(month == 6, NA, 999)
)

Q <- Qlearn(dat,
            Q_hat ~
              noise +
              tumor_mass + dose + toxicity, method = "mars", "dose")

sim_test(Q) %>% plots_tab()
```


# Use rpart with reward as a factor

```{r, eval=FALSE, include=FALSE}
set.seed(20161027)
dat <- dat_long %>% mutate(
  Q_hat = ifelse(month == 6, NA,
                 ifelse(month == 5, reward, 0)),
  Q_hat = ifelse(Q_hat == -65 | Q_hat == -55, -60, Q_hat) %>% factor(),
  best = ifelse(month == 6, NA, 999)
)

Q <- Qlearn(
  dat,
  Q_hat ~
    tumor_mass + dose + toxicity,
  "dose",
  method = "rpart",
  control =
    rpart.control(
      minsplit = 5,
      minbucket = 1,
      cp = 1e-4,
      xval = 20
    )
)
```

```{r xplor-plots, eval=FALSE, include=FALSE}
dat <- align_df(Q) %>% subset_df(5)

mod <- Q$mod_list[[4]]

ggplot(dat) +
  geom_point(aes(x = tumor_mass, y = reward), shape = 5, color = "red") +
  geom_point(aes(
    x = tumor_mass,
    y = predict(mod) %>%
      apply(
        1, function(z) which.max(z) %>% names() %>% as.numeric()
        )
  ), color = "blue", shape = 2)


ggplot(dat) +
  geom_point(aes(x = toxicity, y = reward), shape = 5, color = "red") +
  geom_point(aes(x = toxicity, y = predict(mod) %>%
      apply(
        1, function(z) which.max(z) %>% names() %>% as.numeric()
        )), color = "blue", shape = 2)
```

```{r, eval=FALSE, include=FALSE}
nested_df <- max_df(dat, Q$mod_list[[5]], Q$formula, idvar = "ID", method = "rpart", nested = T)
set.seed(2)
i <- sample(nested_df$ID, 1)
ggplot(filter(nested_df, ID == i), aes(x = dose, y = preds)) +
  geom_point()

set.seed(5)
ggplot(data = filter(nested_df, ID %in% sample(1:1000, 50))) +
  geom_jitter(mapping = aes(x = dose, y = preds, color = factor(ID), alpha  = 0.5), show.legend = F)
```

```{r, eval=FALSE, include=FALSE}
sim_test(Q) %>% plots_tab()
```

# Add noise to rpart  

```{r, eval=FALSE, include=FALSE}
set.seed(20161027)
dat <- dat_long %>% mutate(
  noise = runif(7000),
  Q_hat = ifelse(month == 6, NA,
                 ifelse(month == 5, reward, 0)),
  best = ifelse(month == 6, NA, 999)
)

Q <- Qlearn(
  dat,
  Q_hat ~
    noise +
    tumor_mass + dose + toxicity,
  "dose",
  method = "rpart",
  control =
    rpart.control(
      minsplit = 10,
      minbucket = 5,
      cp = 1e-4,
      xval = 20
    )
)

sim_test(Q) %>% plots_tab()
```

#### other packages:
MDPtoolbox
iqlearn
qLearn

```{r rf, eval=FALSE, include=FALSE}
mod_rf <- train(
  Q_hat ~ tumor_mass + toxicity + dose,
  data = month5,
  method = "rf",
  na.action = na.exclude
)
```



```{r}
fit_rpart <- function(formula, data, cpmod_type = "min", ...) {
  mod_rpart <- rpart(formula, 
                     data = data, mod_type = "class", ...)
  if (cpmod_type == "min_sd") {
    pruned <- mod_rpart$cptable %>%
      as_data_frame() %>%
      mutate(
        xerror_min = min(xerror),
        xerror_min_sd = ifelse(xerror == xerror_min, xstd, 0) %>% sum(na.rm = T)
      ) %>% filter(near(xerror, xerror_min + xerror_min_sd, tol = 0.01)) %>%
      filter(nsplit == min(nsplit)) %>% 
      select(CP) %>% flatten_dbl() %>%
      prune(mod_rpart, .)
  }
  if (cpmod_type == "min") {
    pruned <- mod_rpart$cptable %>%
      as_data_frame() %>%
      filter(xerror == min(xerror)) %>% 
      filter(nsplit == min(nsplit)) %>% 
      select(CP) %>% flatten_dbl() %>%
      prune(mod_rpart, .)
  }
  pruned
}
```


# sandbox

```{r setup}
rm(list = ls())
knitr::opts_chunk$set(warning = F, message = F)
library(pacman)
p_load(tidyverse, caret, stringr)
```

```{r}
source("sim.R")
source("q-functs.R")
set.seed(20161116)
dat_long <- sim()
```

```{r}
dat_long <- dat_long %>% mutate(
  Q_hat = ifelse(month == 6, NA,
                 ifelse(month == 5, reward, 0)),
  best = ifelse(month == 6, NA, 999)
)
```


```{r}
set.seed(20170128)
Q <- Qlearn(
  data = dat_long,
  formula = Q_hat ~ tumor_mass + dose + toxicity,
  treatment = "dose",
  mod_type = "caret",
  na.action = na.omit,
  method = "glmnet"
  )
```

```{r}
set.seed(20170128)
sim_test(Q) %>% plots_tab()
```


```{r}
source("sim.R")
source("qlearn-functs.R")
set.seed(20161116)
dat_long <- sim()
dat <- dat_long %>% filter(month == 5) %>% mutate(Q_hat = reward)
```

```{r model-fitting}
preProcValues <- preProcess(dat %>% select(tumor_mass, toxicity, Q_hat), method = c("center", "scale"))
trainTransformed <- predict(preProcValues, dat)

grid <- expand.grid(sigma = 2^(seq(-5, 15, 2)),
                    C = 2^(seq(-15, 3, 2)))

set.seed(20170130)
mod_svr <- train(
  Q_hat ~ tumor_mass + toxicity + dose,
  data = trainTransformed,
  na.action = na.omit,
  method = 'svmRadialSigma',
  tuneGrid = grid
)

mod <- mod_svr
plot(mod)
mod$finalModel
```

```{r one-stage-optim, eval=FALSE, include=FALSE}
x = seq(0, 1, 0.01)
model <- mod
idvar <- "ID"
data <- dat
method = "ert"
form <- makeRCS(Q_hat ~ tumor_mass + toxicity + dose, "dose", method = "ert")

data_long <- data %>% 
  select(matches(idvar),
         one_of(form$covariates)) %>%
  mutate(dose = map(1:nrow(.), ~ x),
         Q_hat = 0) %>% 
  unnest() %>% predict(preProcValues, .) %>% select(-Q_hat)

data_preds <- data_long %>%
  mutate(preds = ifelse(is.na(tumor_mass), 0, predict(model, .))) %>%
  group_by_(idvar) %>%
  mutate(max = max(preds),
         best = ifelse(near(preds, max), dose, NA) %>% min(na.rm = T))
preds <- data_preds %>%
  select(-dose, -preds) %>% unique()
```


```{r model-fitting}
set.seed(20170130)

grid <- expand.grid(degree = 3)

mod_mars <- train(
  Q_hat ~ tumor_mass + toxicity + dose,
  data = dat,
  na.action = na.omit,
  method = 'bagEarthGCV',
  tuneGrid = grid
  )

mod <- mod_mars
plot(mod)
mod$finalModel
```

```{r one-stage-optim, eval=FALSE, include=FALSE}
x = seq(0, 1, 0.01)
model <- mod
idvar <- "ID"
data <- dat
method = "mars"
form <- makeRCS(Q_hat ~ tumor_mass + toxicity + dose, "dose", method = "mars")

data_long <- data %>% 
  select(matches(idvar),
         one_of(form$covariates)) %>%
  mutate(dose = map(1:nrow(.), ~ x),
         Q_hat = 0) %>% 
  unnest() %>% predict(preProcValues, .) %>% select(-Q_hat)

data_preds <- data_long %>%
  mutate(preds = ifelse(is.na(tumor_mass), 0, predict(model, .))) %>%
  group_by_(idvar) %>%
  mutate(max = max(preds),
         best = ifelse(near(preds, max), dose, NA) %>% min(na.rm = T))
preds <- data_preds %>%
  select(-dose, -preds) %>% unique()
```

```{r qlearn, eval=FALSE, include=FALSE}
dat_long <- dat_long %>% mutate(
  Q_hat = ifelse(month == 6, NA,
                 ifelse(month == 5, reward, 0)),
  best = ifelse(month == 6, NA, 999)
)

grid <- expand.grid(degree = 3)

set.seed(20170128)
Q <- Q(
  data = dat_long,
  formula = Q_hat ~ tumor_mass + dose + toxicity,
  treatment = "dose",
  mod_type = "caret",
  na.action = na.omit,
  method = 'bagEarthGCV',
  tuneGrid = grid
)
```

```{r full-test}
set.seed(20170128)
sim_test(Q) %>% plots_tab()
```

# GAMSEL

```{r gamsel-single-stage, eval=FALSE, include=FALSE}
# subset only to last month, remove people who have died
dat <- dat_long %>% filter(month == 4) %>% select(reward, tumor_mass, toxicity, dose) 
x <- dat %>% na.omit() %>% select(tumor_mass, toxicity, dose) %>% as.matrix()
y <- dat %>% na.omit() %>% select(reward) %>% as.matrix()

mod1 <- gamsel(x, y)
```

```{r gamsel example data, eval=FALSE, include=FALSE}
rm(list = ls())
data = gendata(
  n = 500,
  p = 12,
  k.lin = 3,
  k.nonlin = 3,
  deg = 8,
  sigma = 0.5
)
attach(data)
bases = pseudo.bases(X, degree = 10, df = 6)
# Gaussian gam
gamsel.out = gamsel(X, y, bases = bases)
par(mfrow = c(1, 2), mar = c(5, 4, 3, 1))
summary(gamsel.out)
gamsel.cv = cv.gamsel(X, y, bases = bases)
par(mfrow = c(1, 1))
plot(gamsel.cv)
par(mfrow = c(3, 4))
plot(gamsel.out, newx = X, index = 20)
```


# STIMA

```{r, eval=FALSE, include=FALSE}
# STIMA ---------------------------------------------------------------

rm(list = ls())
library(pacman)
p_load(tidyverse, stima, rpart)

source("./code/sim3.R")
set.seed(20161116)
dat_long <- sim()

# subset only to last month, remove people who have died
dat <- dat_long %>% filter(month == 5) %>%
  select(ID, reward, tumor_mass, toxicity, dose)

mod <- stima(data = dat %>% select(reward, everything(), -ID) %>% na.omit(),
      maxsplit = 10)

round(mod$full, digits=2)

mod$trunk

mod %>% summary()
pmod <- prune(mod)
plot(mod)

predict(mod)

plot(mod)
```


# SVR

```{r}
preProcValues <- preProcess(dat_long %>% select(tumor_mass, toxicity), method = c("center", "scale"))
trainTransformed <- predict(preProcValues, dat_long)

set.seed(20170128)
Q <- Qlearn(
  data = trainTransformed,
  formula = Q_hat ~ tumor_mass + dose + toxicity,
  treatment = "dose",
  mod_type = "caret",
  na.action = na.omit,
  method = 'svmRadialSigma',
  tuneGrid = expand.grid(sigma = 2^(seq(-5, 15, 2)),
                    C = 2^(seq(-15, 3, 2)))
  )
```

```{r}
set.seed(20170128)
sim_test(Q) %>% plots_tab()
```


# old qlearn-fucnts

```{r}
 # Q-learning functions ----------------------------------------------------

makeRCS <- function(formula, treatment, mod_type = "rcs") {
  form_char <- as.character(formula)
  response <- form_char[2]
  predictors <- form_char[3]
  predictor_names <- strsplit(predictors, " \\+ ")[[1]]
  if (mod_type == "rcs") {
    form_base_rcs <- paste(response,
                           "~",
                           paste0("rcs(", predictor_names, ")", collapse = " + "))
    ints <-
      paste0("rcs(", predictor_names, ")", " %ia% ", "rcs(", treatment, ")")
    trtbytrt <-
      paste0("rcs(", treatment, ")", " %ia% ", "rcs(", treatment, ")")
    ints <- ints[ints != trtbytrt]
    ints <- paste(ints, collapse = " + ")
    formula <- paste(c(form_base_rcs, ints), collapse = " + ")
  }
  covariates <- predictor_names[!(predictor_names %in% treatment)]
  list(formula = as.formula(formula), covariates = covariates, treatment = treatment)
}

fit_rcs <- function(formula, data, ...) {
  ols(
    formula,
    x = T,
    y = T,
    data,
    ...
  )
}

fit_rpart <- function(formula, data, cpmod_type = "min", ...) {
  mod_rpart <- rpart(formula, 
                     data = data, mod_type = "class", ...)
  if (cpmod_type == "min_sd") {
    pruned <- mod_rpart$cptable %>%
      as_data_frame() %>%
      mutate(
        xerror_min = min(xerror),
        xerror_min_sd = ifelse(xerror == xerror_min, xstd, 0) %>% sum(na.rm = T)
      ) %>% filter(near(xerror, xerror_min + xerror_min_sd, tol = 0.01)) %>%
      filter(nsplit == min(nsplit)) %>% 
      select(CP) %>% flatten_dbl() %>%
      prune(mod_rpart, .)
  }
  if (cpmod_type == "min") {
    pruned <- mod_rpart$cptable %>%
      as_data_frame() %>%
      filter(xerror == min(xerror)) %>% 
      filter(nsplit == min(nsplit)) %>% 
      select(CP) %>% flatten_dbl() %>%
      prune(mod_rpart, .)
  }
  pruned
}


max_df <- function(data, model, form, idvar = NULL, mod_type, x = seq(0, 1, by = 0.01),  nested = F) {
  if (is.null(idvar)) {
    data <- data %>% mutate(ID = 1:nrow(.))
    idvar <- "ID"
  }
  data_long <- data %>%
    select(matches(idvar),
           one_of(form$covariates)) %>%
    mutate(dose = map(1:nrow(.), ~ x)) %>%
    unnest()
  if (mod_type == "rpart") {
    data_preds <- data_long %>%
      mutate(preds = predict(model, .) %>%
               apply(1, function(z) as.numeric(names(which.max(z))))) %>% 
      group_by_(idvar) %>%
      mutate(max = max(preds),
             best = ifelse(preds == max, dose, NA) %>% median(na.rm = T)
      )
  }
  if (mod_type == "ranger") {
    data_preds <- data_long %>%
      mutate(preds = ifelse(
        !is.na(tumor_mass),
        predict(model, data_long %>% na.omit()) %>% predictions(),
        0
      )) %>%
      group_by_(idvar) %>%
      mutate(max = max(preds),
             best = (which.max(preds) - 1) / 100) 
  } else {
    data_preds <- data_long %>%
      mutate(preds = ifelse(is.na(tumor_mass), 0, predict(model, .))) %>%
      group_by_(idvar) %>%
      mutate(max = max(preds),
             best = ifelse(near(preds, max), dose, NA) %>% min(na.rm = T))
  }
  if (nested == T) {
    data_preds
  } else {
    data_preds %>%
      select(-dose, -preds) %>% unique()  
  }
}

one_step_Q <- function(formula, treatment, data, mod_type, ...) {
  form <- makeRCS(formula, treatment, mod_type) 
  if (mod_type == "rcs") {
    model <- fit_rcs(form$formula, data, ...)
  }
  if (mod_type == "caret") {
    model <- train(formula,
                   data,
                   ...)
  }
  if (mod_type == "mars") {
    model <- earth(formula = formula,
                   data = na.omit(data),
                   ...)
  }
  if (mod_type == "rpart") {
    data <- data %>% mutate(Q_hat = factor(Q_hat))
    model <- fit_rpart(form$formula,
                       data,
                       ...)
  }
  if (mod_type == "ert") {
    model <- train(form$formula,
                   data,
                   method = 'extraTrees',
                   na.action = na.omit,
                   tuneGrid = expand.grid(mtry = 3,
                                          numRandomCuts = 1:3),
                   ntree = 50, # G in CRT paper
                   nodesize = 2, # nmin in CRT paper
                   ...)
  }
  if (mod_type == "ranger") {
    model <- ranger(formula,
                    na.omit(data),
                    always.split.variables = treatment,
                    ...)
  }
  new_dat <- max_df(data, model, form, mod_type = mod_type)
  list(formula = form, model = model, max = new_dat$max, best = new_dat$best, data_new = new_dat)
}

Qlearn <- function(data, formula, treatment, mod_type, ...) {
  mod_list <- list()
  for (i in 4:0) {
    dat <- filter(data, month == i + 1)
    Q1 <- one_step_Q(formula = formula,
                     data = dat,
                     treatment = treatment,
                     mod_type = mod_type,
                     ...)
    mod_list[[i + 2]] <- Q1$model
    data[data$month == i, ]$Q_hat <- dat$reward + Q1$max
    data[data$month == (i + 1), ]$best <- Q1$best
    if (i == 0) {
      subsetted_df <- filter(data, month == i)
      mod_list[[i + 1]] <- Q1$model
      Q1 <- one_step_Q(formula,
                       data = dat,
                       treatment = treatment, 
                       mod_type = mod_type)
      data[data$month == i, ]$best <- Q1$best
    }
  }
  list(data = data, mod_list = mod_list, formula = Q1$formula, mod_type = mod_type)
}

# Getting results functions -----------------------------------------------

align_df <- function(Q) {
  Q$data %>%
    select(ID,
           month,
           dose,
           best,
           reward,
           Q_hat,
           tumor_mass,
           toxicity,
           died) %>%
    mutate(reward = lag(reward),
           Q_hat = lag(Q_hat),
           best = ifelse(died != 1 | is.na(died), best, NA))
}

plots_tab <- function(dat_test_long) {
  dat_long_summ <- dat_test_long %>% group_by(group, month) %>% 
    summarise(
      mean_tox = mean(toxicity, na.rm = T),
      mean_tumor = mean(tumor_mass, na.rm = T)
    ) %>% mutate(
      sum_means = mean_tox + mean_tumor
    )
  
  plot_tox <- ggplot(data = dat_long_summ) +
    geom_line(mapping = aes(
      x = month,
      y = mean_tox,
      color = group,
      group = group
    ))
  
  plot_tumor <- ggplot(data = dat_long_summ) +
    geom_line(mapping = aes(
      x = month,
      y = mean_tumor,
      color = group,
      group = group
    ))
  
  plot_sum <- ggplot(data = dat_long_summ) +
    geom_line(mapping = aes(
      x = month,
      y = sum_means,
      color = group,
      group = group
    ))
  
  tab <-
    dat_test_long %>% group_by(group) %>%
    summarise(num_died = sum(died, na.rm = T),
              prop_died = num_died / 200)
  
  list(
    plot_tox = plot_tox,
    plot_tumor = plot_tumor,
    plot_sum = plot_sum,
    table_deaths = tab
  )
}

```

